// TODO P A4 why no keys?
  //TODO P A4 .keys only returns keys for members implemented in that object itself, and not those implemented by objects in its prototype chain.
  //TODO P A4 That's why dumpProperties() iterates down though .getPrototypeOf.
  //TODO P A4 If you inspect a dumpProperties() output, you'll see that Fitbit element objects usually(?) don't have ANYTHING implemented in them;
  //TODO P A4 all the API is in prototypes.
  //TODO P A4 You could modify your inspectObject() to descend through the prototype chain using a loop or recursion,
  //TODO P A4 or you could pass myElObj.getPrototypeOf() to it and see what it spits out. Then try myElObj.getPrototypeOf().getPrototypeOf(), etc!
  //TODO P A4 As an aside, I tried calling Fitbit API members directly from the prototype object in which they're implemented, rather than via the use element.
  //TODO P A4 JS was happy, but the Fitbit API was not. I reported this in discord.
  //TODO this is not, what I intended, so maybe define mainEl in here?
  //TODO P A5 can dumpProperties() display 'inherit'?
  
  
  
//TODO P A5 Since the answer to A4 turned out NOT to be related to 'inherit' property values, I no longer feel the need to answer this question. :P
//TODO P A2 You CAN'T even set test.main.text or style.font-anything
//TODO P A2 .main is a different type of object to .light and .shadow. .main returns the Fitbit element object, whereas the others return objects made by createSubText.
//TODO P A2 It isn't surprising that .main behaves differently to the others.
//TODO P A2 More importantly, I'm not sure you want callers messing with main's element object, as they could then change stuff you don't want changed.
//TODO P A2 Think through the design of your API; eg, should .text be set on top-level object, or on .main?
//TODO P A2 Since text should be the same in ALL subText elements, I can't see why you'd want to be able to set it on one of them only.
//TODO P A2 What should users actually be able to do with main? Maybe .main should be like .light and .shadow but without .x and .y.
//TODO P A2 Similarly, I'm very uncomfortable with things like test.light.style.fontSize = 100; as you've tried about. Does it make sense to allow this?
//TODO P A3 I can set test.main.style.fontSize and it doesn't get passed to light and shadow, as I couldn't do that in the redraw. Setting test.style.fontsize works fine for all.
//TODO P A3 I don't see this as a problem, for same reason as A2. Design the API before implementing it. It isn't necessary for things to be settable in every possible way;
//TODO P A3 that will just lead to confusion aboout which setting should take priority.
//TODO P A3 Perhaps a good principle is that if a setting should affect the WHOLE widget (ie, ALL subTexts), it should be settable on the widget (use) itself; eg, .text, .fontSize.
//TODO P A3 If a setting has relevance to an individual subText independently of the others, it should be settable on that subText; eg, .fill.
//TODO P A3 I don't know if this helps, but try to think of the API from the point of view of a widget USER rather than as the widget DEVELOPER.
//TODO P A3 As DEVELOPER, you know that it contains three textEls, and you want to be able to set everything everywhere in every possible way.
//TODO P A3 A widget USER would probably prefer to think of the widget as one magic <text>. It displays ONE string, has ONE location, ONE fontSize, etc. The magic is that it can add a
//TODO P A3 highlight above and below the text. The API should align with that pragmatic and minimalist view.




 // TODO P A1 Why does setting .text on widget (use) work?
  // TODO P A1 Isn't it because you've got Object.defineProperty(el, 'text'...
  // TODO P A1 ...which copies from use el into mainEl, and then calls redraw to put it everywhere. That seems like a good system to me.